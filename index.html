<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>纯JavaScript Markdown预览器</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f7fa;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }
        
        .description {
            font-size: 1rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .editor-container {
            display: flex;
            flex-direction: column;
            height: 70vh;
        }
        
        @media (min-width: 768px) {
            .editor-container {
                flex-direction: row;
            }
        }
        
        .editor-panel {
            flex: 1;
            padding: 15px;
            border: 1px solid #e1e4e8;
            overflow: auto;
        }
        
        #markdown-input {
            width: 100%;
            height: 100%;
            padding: 15px;
            border: none;
            resize: none;
            font-family: monospace;
            font-size: 16px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        
        #markdown-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px #3498db;
        }
        
        #preview {
            padding: 15px;
            overflow: auto;
            background-color: white;
            border-radius: 5px;
        }
        
        /* Markdown样式 */
        #preview h1, #preview h2, #preview h3 {
            margin-top: 1.5em;
            margin-bottom: 0.8em;
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.3em;
        }
        
        #preview h1 { font-size: 2em; }
        #preview h2 { font-size: 1.7em; }
        #preview h3 { font-size: 1.4em; }
        
        #preview p {
            margin-bottom: 1em;
        }
        
        #preview strong {
            font-weight: bold;
            color: #e74c3c;
        }
        
        #preview em {
            font-style: italic;
            color: #3498db;
        }
        
        #preview ul, #preview ol {
            margin-left: 20px;
            margin-bottom: 1em;
        }
        
        #preview li {
            margin-bottom: 0.5em;
        }
        
        #preview code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        #preview pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow: auto;
            margin: 1em 0;
        }
        
        #preview blockquote {
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin: 1em 0;
            color: #7f8c8d;
        }
        
        #preview a {
            color: #2980b9;
            text-decoration: none;
        }
        
        #preview a:hover {
            text-decoration: underline;
        }
        
        #preview img {
            max-width: 100%;
            margin: 1em 0;
            border-radius: 5px;
        }
        
        .panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
            display: flex;
            align-items: center;
        }
        
        .panel-title::before {
            content: "•";
            margin-right: 8px;
            color: #3498db;
        }
        
        .divider {
            height: 1px;
            background: linear-gradient(to right, transparent, #e1e4e8, transparent);
            margin: 10px 0;
        }
        
        .help-text {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.9em;
            color: #7f8c8d;
        }
        
        .help-text h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .help-text ul {
            margin-left: 20px;
        }
        
        .help-text li {
            margin-bottom: 8px;
        }
        
        .help-text code {
            background-color: #e1e4e8;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>纯JavaScript Markdown预览器</h1>
            <p class="description">无需任何外部库 - 直接在浏览器中预览Markdown</p>
        </header>
        
        <div class="editor-container">
            <div class="editor-panel">
                <div class="panel-title">Markdown输入</div>
                <textarea id="markdown-input" placeholder="在此输入Markdown内容..."># Markdown预览器示例

# 你的第一个端口破解器
## 一、如何使用模版
打开你的解决方案后，你将看到如下内容
```cs
using BepInEx;
using BepInEx.Hacknet;

namespace HacknetPluginTemplate;

[BepInPlugin(ModGUID, ModName, ModVer)]
public class HacknetPluginTemplate : HacknetPlugin
{
    public const string ModGUID = "com.Windows10CE.Template";
    public const string ModName = "If you leave these the same, I will kill you.";
    public const string ModVer = "1.0.0";

    public override bool Load()
    {
        return true;
    }
}

```
你需要修改其中的 **MODGUID** **ModName** **ModVer**和开头的类名，同时添加一些引用库这里我提供了一个示例：
```cs
using BepInEx;
using BepInEx.Hacknet;
using Pathfinder;
using Hacknet;

namespace ASimpleMod;//命名空间，没啥用，可以不写。写了记得在跨文档使用函数的时候using你的命名空间。

[BepInPlugin(ModGUID, ModName, ModVer)]
public class TestMod : HacknetPlugin
{
    public const string ModGUID = "com.whydoyouthinksomeonewillfoundthis.test";
    public const string ModName = "TestMod";
    public const string ModVer = "1.0.0";

    public override bool Load()//后文我们会简称为 “主文件的Load函数”
    {
        
        Console.ForegroundColor = ConsoleColor.Cyan;//设置颜色
        Console.WriteLine("TestMod Load Finished!");//cmd终端输出文字
        Console.ResetColor();//重置颜色
        os.write("HERE!")
        return true;
    }
}
```
按下CTRL+SHIFT+B组合按键观察控制台输出，你就可以在这个路径下找到编译好的mod文件了（.dll） 

- **.\bin\Debug\net472** 

现在，复制这个dll文件到你的测试拓展下面，新建一个文件夹命名为plugins然后把你的dll放进去。

运行HacknetPathfinder.exe并选择你的拓展打开，你应该就能看见你的Hacknet打开的CMD终端输出了一行**TestMod Load Finished!**

游戏内终端输出了一行**HERE!**

## 二、你的第一个EXE和自定义端口
PS：由于篇幅有限，我们只会对需要了解的C#语法进行解释，剩余部分不做过多展开。
### 1.注册端口和EXE
按下**CTRL+SHIFT+A**新建一个.cs文件，删除全部内容。然后复制粘贴头部using开始。

(虽然看起来臃肿，但是至少不会因为少个using多找一次bug
导致红温。)
```csharp
using BepInEx;
using HarmonyLib;
using Hacknet;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Pathfinder.Action;
using Pathfinder.Administrator;
using Pathfinder.Util;
using Pathfinder.Daemon;
using Pathfinder.GUI;
using Pathfinder.Mission;
using Pathfinder.Util.XML;
using System;
using System.IO;
using System.Collections.Generic;
using Pathfinder;
using Hacknet.Extensions;
using BepInEx.Hacknet;
using System.Diagnostics;
```

通过修改主文件Load函数，注册一个端口和一个EXE
```csharp
using BepInEx;
using BepInEx.Hacknet;
using Pathfinder;
using Hacknet;

namespace ASimpleMod;

[BepInPlugin(ModGUID, ModName, ModVer)]
public class TestMod : HacknetPlugin
{
    public const string ModGUID = "com.whydoyouthinksomeonewillfoundthis.test";
    public const string ModName = "TestMod";
    public const string ModVer = "1.0.0";

    public override bool Load()
    {
        
        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.WriteLine("TestMod Load Finished!");
        Console.ResetColor();//重置颜色
        Pathfinder.Port.PortManager.RegisterPort("EntechPort","Entech","1270")//协议，probe界面显示的名称，端口号
        Pathfinder.Executable.ExecutableManager.RegisterExecutable<EntechPortExploit>("#EnTechPortExploit#");//<>内部填写你的函数名，后面的是自替换符。
        return true;
    }
}

```


在新建的文件中添加如下内容定义一个EXE

```csharp
using BepInEx;
using HarmonyLib;
using Hacknet;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Pathfinder.Action;
using Pathfinder.Administrator;
using Pathfinder.Util;
using Pathfinder.Daemon;
using Pathfinder.GUI;
using Pathfinder.Mission;
using Pathfinder.Util.XML;
using System;
using System.IO;
using System.Collections.Generic;
using Pathfinder;
using Hacknet.Extensions;
using BepInEx.Hacknet;
using System.Diagnostics;
public class TestExecutable : Pathfinder.Executable.BaseExecutable
{
    public EntechPortExploit(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) {
        this.ramCost = 200;//你的内存占用
        this.IdentifierName = "WEBPORT INJECTOR";//你的程序在ram栏显示的名称
        //输入this.查看更多可定义的项目
    }

    public override void LoadContent()//首次执行后触发的内容
    {
        base.LoadContent();
    }

    public override void Draw(float t)//绘制程序窗口
    {
        base.Draw(t);
        drawTarget();
        drawOutline();
        
    }

    private float lifetime = 0f;
    public override void Update(float t)//循环触发（每帧）
    {
        base.Update(t);
        lifetime += t;
    }
}
```
### 2.编写EXE功能
首先，我们需要设计一个好他的底层代码逻辑。

一个端口破解器理论上的过程应该是这样子的：

**运行EXE->检测是否有该端口并获取端口号&检查是否提供了正确的端口号->检查是否需要额外的要求（如额外端口破解需求）->花里胡哨的动画特效->打开端口->自动退出/手动Kill/保持运行**

那么，我们先不管那些花里胡哨的动画和什么额外的端口需求和整活效果（比如SSL需要其他端口开启，TempestGadgets的Sig32破解器会随机打开或者关闭端口或防火墙或代理），我们先做最基础的实现。

- 1.消耗时间设置为20
- 2.exe在ram栏会显示进度
- 3.自动退出

首先，对于消耗时间我们在 **Update()** 中循环检测lifetime。然后同时实时更新 **Draw()** 内部的绘制倒计时。最后开启端口。
```csharp
using BepInEx;
using HarmonyLib;
using Hacknet;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Pathfinder.Action;
using Pathfinder.Administrator;
using Pathfinder.Util;
using Pathfinder.Daemon;
using Pathfinder.GUI;
using Pathfinder.Mission;
using Pathfinder.Util.XML;
using System;
using System.IO;
using System.Collections.Generic;
using Pathfinder;
using Hacknet.Extensions;
using BepInEx.Hacknet;
using System.Diagnostics;
public class TestExecutable : Pathfinder.Executable.BaseExecutable
{
    private Computer targetComputer;//定义一个用于存储或者说代指当前连接节点的变量
    private int netPort;//定义一个用来存储端口（号）的变量
    private const int needtime = 5f; // 将破解需要的时间存储在常量中
    private float time = 0f; // 用于跟踪已经过去的时间
    public TestExecutable(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) {
        this.ramCost = 200;//你的内存占用
        this.IdentifierName = "WEBPORT INJECTOR";//你的程序在ram栏显示的名称
        //输入this.查看更多可定义的项目
    }

    public override void LoadContent()//首次执行后触发的内容
    {
        base.LoadContent();
        targetComputer = (os.connectedComp != null) ? os.connectedComp : os.thisComputer;//人话：目标计算机=（如果你现在连计算机了）获取当前连接的计算机 不然 就这个电脑了。
        if (targetComputer == null)//万一真没连怎么办呢？
        {
            os.write("ERROR: Target computer not found!");//没找到节点
            needsRemoval = true;//直接消失
            return;//返回
        }
        netPort = targetComputer.GetDisplayPortNumberFromCodePort(1270);//从目标计算机上得到端口号为1270的端口
        if (Args.Length < 2 || !Int32.TryParse(Args[1], out int port) || port != netPort)
        /*这个条件在以下任一情况下会返回 true：

          参数不足（少于2个）
          第二个参数不是有效数字
          端口号与期望值不匹配
        （索引为EXENAME(0号位置) 1270（1号位置））
        */
        {
            os.write("ERROR FOUND!Target Port is Closed or Missing!");//没找到你说的端口
            needsRemoval = true;//直接消失
            return;
        }
    }

    public override void Draw(float t)//你觉得呢？
    {
        base.Draw(t);
        drawTarget();
        drawOutline();
        Vector2 centerpos = new Vector2(bounds.width / 2, bounds.height / 2); // 计算窗口中心位置
        string progressText = $"NEEDTIME {time}" // 显示剩余时间
    }

    private float lifetime = 0f;
    public override void Update(float t)//循环触发（每帧）
    {
        base.Update(t);
        lifetime += t;
        if (lifetime >= 0.1f)
        {
          time += lifetime;
          lifetime = 0f;
          
        }
    }
    }


```
现在，按下**CTRL+SHIFT+B**编译，然后找到老地方的dll替换掉你拓展的第一次编译的dll。

打开你的拓展的一个节点，然后在端口处添加你1270端口，并在bin里写上#EnTechPortExploit#，打开游戏运行破解器，你就可以看见效果了。

（Tips：在快捷方式后面空格并添加字段使用参数启动-enabledebug -enablefc -allowextpublish就可以直接使用fh快速破解节点，使用dscan 节点ID 显示节点。）




</textarea>
            </div>
            
            <div class="editor-panel">
                <div class="panel-title">实时预览</div>
                <div id="preview"></div>
            </div>
        </div>
        
        <div class="help-text">
            <h3>Markdown快速参考</h3>
            <ul>
                <li><strong>标题</strong>: <code># 一级标题</code>, <code>## 二级标题</code></li>
                <li><strong>粗体</strong>: <code>**粗体文本**</code></li>
                <li><strong>斜体</strong>: <code>*斜体文本*</code></li>
                <li><strong>列表</strong>: <code>- 列表项</code></li>
                <li><strong>代码块</strong>: 用三个反引号包围代码</li>
                <li><strong>引用</strong>: <code>&gt; 引用文本</code></li>
                <li><strong>链接</strong>: <code>[链接文本](URL)</code></li>
                <li><strong>图片</strong>: <code>![替代文本](图片URL)</code></li>
            </ul>
        </div>
    </div>

    <script>
        // Markdown解析函数
        function parseMarkdown(markdown) {
            // 替换标题
            markdown = markdown.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            markdown = markdown.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            markdown = markdown.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            
            // 替换粗体和斜体
            markdown = markdown.replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>');
            markdown = markdown.replace(/\*(.*?)\*/gim, '<em>$1</em>');
            
            // 替换无序列表
            markdown = markdown.replace(/^\s*[-*] (.*$)/gim, '<li>$1</li>');
            markdown = markdown.replace(/(<li>.*<\/li>)/gim, '<ul>$1</ul>');
            
            // 替换代码块
            markdown = markdown.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
            
            // 替换内联代码
            markdown = markdown.replace(/`(.*?)`/g, '<code>$1</code>');
            
            // 替换引用
            markdown = markdown.replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>');
            
            // 替换链接
            markdown = markdown.replace(/\[([^\[]+)\]\(([^\)]+)\)/g, '<a href="$2">$1</a>');
            
            // 替换图片
            markdown = markdown.replace(/!\[([^\[]+)\]\(([^\)]+)\)/g, '<img src="$2" alt="$1">');
            
            // 替换段落
            markdown = markdown.replace(/\n\n/g, '</p><p>');
            markdown = '<p>' + markdown + '</p>';
            
            // 替换换行符
            markdown = markdown.replace(/\n/g, '<br>');
            
            return markdown;
        }
        
        // 获取DOM元素
        const markdownInput = document.getElementById('markdown-input');
        const preview = document.getElementById('preview');
        
        // 初始渲染
        preview.innerHTML = parseMarkdown(markdownInput.value);
        
        // 监听输入变化
        markdownInput.addEventListener('input', function() {
            preview.innerHTML = parseMarkdown(this.value);
        });
        
        // 添加键盘快捷键
        markdownInput.addEventListener('keydown', function(e) {
            // 支持Tab键缩进
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                
                // 插入Tab字符
                this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                
                // 恢复光标位置
                this.selectionStart = this.selectionEnd = start + 4;
            }
        });
    </script>
</body>
</html>