<h1 class="code-line" data-line-start=0 data-line-end=1 ><a id="_0"></a>你的第一个端口破解器</h1>
<h2 class="code-line" data-line-start=1 data-line-end=2 ><a id="_1"></a>一、如何使用模版</h2>
<p class="has-line-data" data-line-start="2" data-line-end="3">打开你的解决方案后，你将看到如下内容</p>
<pre><code class="has-line-data" data-line-start="4" data-line-end="23" class="language-cs"><span class="hljs-keyword">using</span> BepInEx;
<span class="hljs-keyword">using</span> BepInEx.Hacknet;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">HacknetPluginTemplate</span>;

[BepInPlugin(ModGUID, ModName, ModVer)]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HacknetPluginTemplate</span> : <span class="hljs-title">HacknetPlugin</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModGUID = <span class="hljs-string">"com.Windows10CE.Template"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModName = <span class="hljs-string">"If you leave these the same, I will kill you."</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModVer = <span class="hljs-string">"1.0.0"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Load</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}

</code></pre>
<p class="has-line-data" data-line-start="23" data-line-end="24">你需要修改其中的 <strong>MODGUID</strong> <strong>ModName</strong> <strong>ModVer</strong>和开头的类名，同时添加一些引用库这里我提供了一个示例：</p>
<pre><code class="has-line-data" data-line-start="25" data-line-end="50" class="language-cs"><span class="hljs-keyword">using</span> BepInEx;
<span class="hljs-keyword">using</span> BepInEx.Hacknet;
<span class="hljs-keyword">using</span> Pathfinder;
<span class="hljs-keyword">using</span> Hacknet;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">ASimpleMod</span>;<span class="hljs-comment">//命名空间，没啥用，可以不写。写了记得在跨文档使用函数的时候using你的命名空间。</span>

[BepInPlugin(ModGUID, ModName, ModVer)]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestMod</span> : <span class="hljs-title">HacknetPlugin</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModGUID = <span class="hljs-string">"com.whydoyouthinksomeonewillfoundthis.test"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModName = <span class="hljs-string">"TestMod"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModVer = <span class="hljs-string">"1.0.0"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Load</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//后文我们会简称为 “主文件的Load函数”</span>
    </span>{
        
        Console.ForegroundColor = ConsoleColor.Cyan;<span class="hljs-comment">//设置颜色</span>
        Console.WriteLine(<span class="hljs-string">"TestMod Load Finished!"</span>);<span class="hljs-comment">//cmd终端输出文字</span>
        Console.ResetColor();<span class="hljs-comment">//重置颜色</span>
        os.write(<span class="hljs-string">"HERE!"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}
</code></pre>
<p class="has-line-data" data-line-start="50" data-line-end="51">按下CTRL+SHIFT+B组合按键观察控制台输出，你就可以在这个路径下找到编译好的mod文件了（.dll）</p>
<ul>
<li class="has-line-data" data-line-start="52" data-line-end="54"><strong>.\bin\Debug\net472</strong></li>
</ul>
<p class="has-line-data" data-line-start="54" data-line-end="55">现在，复制这个dll文件到你的测试拓展下面，新建一个文件夹命名为plugins然后把你的dll放进去。</p>
<p class="has-line-data" data-line-start="56" data-line-end="57">运行HacknetPathfinder.exe并选择你的拓展打开，你应该就能看见你的Hacknet打开的CMD终端输出了一行<strong>TestMod Load Finished!</strong></p>
<p class="has-line-data" data-line-start="58" data-line-end="59">游戏内终端输出了一行<strong>HERE!</strong></p>
<h2 class="code-line" data-line-start=60 data-line-end=61 ><a id="EXE_60"></a>二、你的第一个EXE和自定义端口</h2>
<p class="has-line-data" data-line-start="61" data-line-end="62">PS：由于篇幅有限，我们只会对需要了解的C#语法进行解释，剩余部分不做过多展开。</p>
<h3 class="code-line" data-line-start=62 data-line-end=63 ><a id="1EXE_62"></a>1.注册端口和EXE</h3>
<p class="has-line-data" data-line-start="63" data-line-end="64">按下<strong>CTRL+SHIFT+A</strong>新建一个.cs文件，删除全部内容。然后复制粘贴头部using开始。</p>
<p class="has-line-data" data-line-start="65" data-line-end="67">(虽然看起来臃肿，但是至少不会因为少个using多找一次bug<br>
导致红温。)</p>
<pre><code class="has-line-data" data-line-start="68" data-line-end="88" class="language-csharp"><span class="hljs-keyword">using</span> BepInEx;
<span class="hljs-keyword">using</span> HarmonyLib;
<span class="hljs-keyword">using</span> Hacknet;
<span class="hljs-keyword">using</span> Microsoft.Xna.Framework;
<span class="hljs-keyword">using</span> Microsoft.Xna.Framework.Graphics;
<span class="hljs-keyword">using</span> Pathfinder.Action;
<span class="hljs-keyword">using</span> Pathfinder.Administrator;
<span class="hljs-keyword">using</span> Pathfinder.Util;
<span class="hljs-keyword">using</span> Pathfinder.Daemon;
<span class="hljs-keyword">using</span> Pathfinder.GUI;
<span class="hljs-keyword">using</span> Pathfinder.Mission;
<span class="hljs-keyword">using</span> Pathfinder.Util.XML;
<span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.IO;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> Pathfinder;
<span class="hljs-keyword">using</span> Hacknet.Extensions;
<span class="hljs-keyword">using</span> BepInEx.Hacknet;
<span class="hljs-keyword">using</span> System.Diagnostics;
</code></pre>
<p class="has-line-data" data-line-start="89" data-line-end="90">通过修改主文件Load函数，注册一个端口和一个EXE</p>
<pre><code class="has-line-data" data-line-start="91" data-line-end="118" class="language-csharp"><span class="hljs-keyword">using</span> BepInEx;
<span class="hljs-keyword">using</span> BepInEx.Hacknet;
<span class="hljs-keyword">using</span> Pathfinder;
<span class="hljs-keyword">using</span> Hacknet;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">ASimpleMod</span>;

[BepInPlugin(ModGUID, ModName, ModVer)]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestMod</span> : <span class="hljs-title">HacknetPlugin</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModGUID = <span class="hljs-string">"com.whydoyouthinksomeonewillfoundthis.test"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModName = <span class="hljs-string">"TestMod"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModVer = <span class="hljs-string">"1.0.0"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Load</span>(<span class="hljs-params"></span>)
    </span>{
        
        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.WriteLine(<span class="hljs-string">"TestMod Load Finished!"</span>);
        Console.ResetColor();<span class="hljs-comment">//重置颜色</span>
        Pathfinder.Port.PortManager.RegisterPort(<span class="hljs-string">"EntechPort"</span>,<span class="hljs-string">"Entech"</span>,<span class="hljs-string">"1270"</span>)<span class="hljs-comment">//协议，probe界面显示的名称，端口号</span>
        Pathfinder.Executable.ExecutableManager.RegisterExecutable&lt;EntechPortExploit&gt;(<span class="hljs-string">"#EnTechPortExploit#"</span>);<span class="hljs-comment">//&lt;&gt;内部填写你的函数名，后面的是自替换符。</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}

</code></pre>
<p class="has-line-data" data-line-start="120" data-line-end="121">在新建的文件中添加如下内容定义一个EXE</p>
<pre><code class="has-line-data" data-line-start="123" data-line-end="171" class="language-csharp">using BepInEx;
using HarmonyLib;
using Hacknet;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Pathfinder.Action;
using Pathfinder.Administrator;
using Pathfinder.Util;
using Pathfinder.Daemon;
using Pathfinder.GUI;
using Pathfinder.Mission;
using Pathfinder.Util.XML;
using System;
using System.IO;
using System.Collections.Generic;
using Pathfinder;
using Hacknet.Extensions;
using BepInEx.Hacknet;
using System.Diagnostics;
public class TestExecutable : Pathfinder.Executable.BaseExecutable
{
    public EntechPortExploit(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) {
        this.ramCost = 200;//你的内存占用
        this.IdentifierName = "WEBPORT INJECTOR";//你的程序在ram栏显示的名称
        //输入this.查看更多可定义的项目
    }

    public override void LoadContent()//首次执行后触发的内容
    {
        base.LoadContent();
    }

    public override void Draw(float t)//绘制程序窗口
    {
        base.Draw(t);
        drawTarget();
        drawOutline();
        
    }

    private float lifetime = 0f;
    public override void Update(float t)//循环触发（每帧）
    {
        base.Update(t);
        lifetime += t;
    }
}
</code></pre>
<h3 class="code-line" data-line-start=171 data-line-end=172 ><a id="2EXE_171"></a>2.编写EXE功能</h3>
<p class="has-line-data" data-line-start="172" data-line-end="173">首先，我们需要设计一个好他的底层代码逻辑。</p>
<p class="has-line-data" data-line-start="174" data-line-end="175">一个端口破解器理论上的过程应该是这样子的：</p>
<p class="has-line-data" data-line-start="176" data-line-end="177"><strong>运行EXE-&gt;检测是否有该端口并获取端口号&amp;检查是否提供了正确的端口号-&gt;检查是否需要额外的要求（如额外端口破解需求）-&gt;花里胡哨的动画特效-&gt;打开端口-&gt;自动退出/手动Kill/保持运行</strong></p>
<p class="has-line-data" data-line-start="178" data-line-end="179">那么，我们先不管那些花里胡哨的动画和什么额外的端口需求和整活效果（比如SSL需要其他端口开启，TempestGadgets的Sig32破解器会随机打开或者关闭端口或防火墙或代理），我们先做最基础的实现。</p>
<ul>
<li class="has-line-data" data-line-start="180" data-line-end="181">1.消耗时间设置为20</li>
<li class="has-line-data" data-line-start="181" data-line-end="182">2.exe在ram栏会显示进度</li>
<li class="has-line-data" data-line-start="182" data-line-end="184">3.自动退出</li>
</ul>
<p class="has-line-data" data-line-start="184" data-line-end="185">首先，对于消耗时间我们在 <strong>Update()</strong> 中循环检测lifetime。然后同时实时更新 <strong>Draw()</strong> 内部的绘制倒计时。最后开启端口。</p>
<pre><code class="has-line-data" data-line-start="186" data-line-end="268" class="language-csharp">using BepInEx;
using HarmonyLib;
using Hacknet;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Pathfinder.Action;
using Pathfinder.Administrator;
using Pathfinder.Util;
using Pathfinder.Daemon;
using Pathfinder.GUI;
using Pathfinder.Mission;
using Pathfinder.Util.XML;
using System;
using System.IO;
using System.Collections.Generic;
using Pathfinder;
using Hacknet.Extensions;
using BepInEx.Hacknet;
using System.Diagnostics;
public class TestExecutable : Pathfinder.Executable.BaseExecutable
{
    private Computer targetComputer;//定义一个用于存储或者说代指当前连接节点的变量
    private int netPort;//定义一个用来存储端口（号）的变量
    private const int needtime = 5f; // 将破解需要的时间存储在常量中
    private float time = 0f; // 用于跟踪已经过去的时间
    public TestExecutable(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) {
        this.ramCost = 200;//你的内存占用
        this.IdentifierName = "WEBPORT INJECTOR";//你的程序在ram栏显示的名称
        //输入this.查看更多可定义的项目
    }

    public override void LoadContent()//首次执行后触发的内容
    {
        base.LoadContent();
        targetComputer = (os.connectedComp != null) ? os.connectedComp : os.thisComputer;//人话：目标计算机=（如果你现在连计算机了）获取当前连接的计算机 不然 就这个电脑了。
        if (targetComputer == null)//万一真没连怎么办呢？
        {
            os.write("ERROR: Target computer not found!");//没找到节点
            needsRemoval = true;//直接消失
            return;//返回
        }
        netPort = targetComputer.GetDisplayPortNumberFromCodePort(1270);//从目标计算机上得到端口号为1270的端口
        if (Args.Length &lt; 2 || !Int32.TryParse(Args[1], out int port) || port != netPort)
        /*这个条件在以下任一情况下会返回 true：

          参数不足（少于2个）
          第二个参数不是有效数字
          端口号与期望值不匹配
        （索引为EXENAME(0号位置) 1270（1号位置））
        */
        {
            os.write("ERROR FOUND!Target Port is Closed or Missing!");//没找到你说的端口
            needsRemoval = true;//直接消失
            return;
        }
    }

    public override void Draw(float t)//你觉得呢？
    {
        base.Draw(t);
        drawTarget();
        drawOutline();
        Vector2 centerpos = new Vector2(bounds.width / 2, bounds.height / 2); // 计算窗口中心位置
        string progressText = $"NEEDTIME {time}" // 显示剩余时间
    }

    private float lifetime = 0f;
    public override void Update(float t)//循环触发（每帧）
    {
        base.Update(t);
        lifetime += t;
        if (lifetime &gt;= 0.1f)
        {
          time += lifetime;
          lifetime = 0f;
          
        }
    }
    }


</code></pre>
<p class="has-line-data" data-line-start="268" data-line-end="269">现在，按下<strong>CTRL+SHIFT+B</strong>编译，然后找到老地方的dll替换掉你拓展的第一次编译的dll。</p>
<p class="has-line-data" data-line-start="270" data-line-end="271">打开你的拓展的一个节点，然后在端口处添加你1270端口，并在bin里写上#EnTechPortExploit#，打开游戏运行破解器，你就可以看见效果了。</p>
<p class="has-line-data" data-line-start="272" data-line-end="273">（Tips：在快捷方式后面空格并添加字段使用参数启动-enabledebug -enablefc -allowextpublish就可以直接使用fh快速破解节点，使用dscan 节点ID 显示节点。）</p>