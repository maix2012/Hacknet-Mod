# 你的第一个端口破解器
## 一、如何使用模版
打开你的解决方案后，你将看到如下内容
```cs
using BepInEx;
using BepInEx.Hacknet;

namespace HacknetPluginTemplate;

[BepInPlugin(ModGUID, ModName, ModVer)]
public class HacknetPluginTemplate : HacknetPlugin
{
    public const string ModGUID = "com.Windows10CE.Template";
    public const string ModName = "If you leave these the same, I will kill you.";
    public const string ModVer = "1.0.0";

    public override bool Load()
    {
        return true;
    }
}

```
你需要修改其中的 **MODGUID** **ModName** **ModVer**和开头的类名，同时添加一些引用库这里我提供了一个示例：
```cs
using BepInEx;
using BepInEx.Hacknet;
using Pathfinder;
using Hacknet;

namespace ASimpleMod;//命名空间，没啥用，可以不写。写了记得在跨文档使用函数的时候using你的命名空间。

[BepInPlugin(ModGUID, ModName, ModVer)]
public class TestMod : HacknetPlugin
{
    public const string ModGUID = "com.whydoyouthinksomeonewillfoundthis.test";
    public const string ModName = "TestMod";
    public const string ModVer = "1.0.0";

    public override bool Load()//后文我们会简称为 “主文件的Load函数”
    {
        
        Console.ForegroundColor = ConsoleColor.Cyan;//设置颜色
        Console.WriteLine("TestMod Load Finished!");//cmd终端输出文字
        Console.ResetColor();//重置颜色
        os.write("HERE!")
        return true;
    }
}
```
按下CTRL+SHIFT+B组合按键观察控制台输出，你就可以在这个路径下找到编译好的mod文件了（.dll） 

- **.\bin\Debug\net472** 

现在，复制这个dll文件到你的测试拓展下面，新建一个文件夹命名为plugins然后把你的dll放进去。

运行HacknetPathfinder.exe并选择你的拓展打开，你应该就能看见你的Hacknet打开的CMD终端输出了一行**TestMod Load Finished!**

游戏内终端输出了一行**HERE!**

## 二、你的第一个EXE和自定义端口
PS：由于篇幅有限，我们只会对需要了解的C#语法进行解释，剩余部分不做过多展开。
### 1.注册端口和EXE
按下**CTRL+SHIFT+A**新建一个.cs文件，删除全部内容。然后复制粘贴头部using开始。

(虽然看起来臃肿，但是至少不会因为少个using多找一次bug
导致红温。)
```csharp
using BepInEx;
using HarmonyLib;
using Hacknet;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Pathfinder.Action;
using Pathfinder.Administrator;
using Pathfinder.Util;
using Pathfinder.Daemon;
using Pathfinder.GUI;
using Pathfinder.Mission;
using Pathfinder.Util.XML;
using System;
using System.IO;
using System.Collections.Generic;
using Pathfinder;
using Hacknet.Extensions;
using BepInEx.Hacknet;
using System.Diagnostics;
```

通过修改主文件Load函数，注册一个端口和一个EXE
```csharp
using BepInEx;
using BepInEx.Hacknet;
using Pathfinder;
using Hacknet;

namespace ASimpleMod;

[BepInPlugin(ModGUID, ModName, ModVer)]
public class TestMod : HacknetPlugin
{
    public const string ModGUID = "com.whydoyouthinksomeonewillfoundthis.test";
    public const string ModName = "TestMod";
    public const string ModVer = "1.0.0";

    public override bool Load()
    {
        
        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.WriteLine("TestMod Load Finished!");
        Console.ResetColor();//重置颜色
        Pathfinder.Port.PortManager.RegisterPort("EntechPort","Entech",1270);//协议，probe界面显示的名称，端口号
        Pathfinder.Executable.ExecutableManager.RegisterExecutable<EntechPortExploit>("#EnTechPortExploit#");//<>内部填写你的函数名，后面的是自替换符。
        return true;
    }
}

```


在新建的文件中添加如下内容定义一个EXE

```csharp
using BepInEx;
using HarmonyLib;
using Hacknet;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Pathfinder.Action;
using Pathfinder.Administrator;
using Pathfinder.Util;
using Pathfinder.Daemon;
using Pathfinder.GUI;
using Pathfinder.Mission;
using Pathfinder.Util.XML;
using System;
using System.IO;
using System.Collections.Generic;
using Pathfinder;
using Hacknet.Extensions;
using BepInEx.Hacknet;
using System.Diagnostics;
public class EntechPortExploit : Pathfinder.Executable.BaseExecutable
{
    public EntechPortExploit(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) {
        this.ramCost = 200;//你的内存占用
        this.IdentifierName = "WEBPORT INJECTOR";//你的程序在ram栏显示的名称
        //输入this.查看更多可定义的项目
    }

    public override void LoadContent()//首次执行后触发的内容
    {
        base.LoadContent();
    }

    public override void Draw(float t)//绘制程序窗口
    {
        base.Draw(t);
        drawTarget();
        drawOutline();
        
    }

    private float lifetime = 0f;
    public override void Update(float t)//循环触发（每帧）
    {
        base.Update(t);
        lifetime += t;
    }
}
```
### 2.编写EXE功能
首先，我们需要设计一个好他的底层代码逻辑。

一个端口破解器理论上的过程应该是这样子的：

**运行EXE->检测是否有该端口并获取端口号&检查是否提供了正确的端口号->检查是否需要额外的要求（如额外端口破解需求）->花里胡哨的动画特效->打开端口->自动退出/手动Kill/保持运行**

那么，我们先不管那些花里胡哨的动画和什么额外的端口需求和整活效果（比如SSL需要其他端口开启，TempestGadgets的Sig32破解器会随机打开或者关闭端口或防火墙或代理），我们先做最基础的实现。

- 1.消耗时间设置为20
- 2.exe在ram栏会显示进度
- 3.自动退出

首先，对于消耗时间我们在 **Update()** 中循环检测lifetime。然后同时实时更新 **Draw()** 内部的绘制倒计时。最后开启端口。
```csharp
using BepInEx;
using HarmonyLib;
using Hacknet;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Pathfinder.Action;
using Pathfinder.Administrator;
using Pathfinder.Util;
using Pathfinder.Daemon;
using Pathfinder.GUI;
using Pathfinder.Mission;
using Pathfinder.Util.XML;
using System;
using System.IO;
using System.Collections.Generic;
using Pathfinder;
using Hacknet.Extensions;
using BepInEx.Hacknet;
using System.Diagnostics;
public class EntechPortExploit : Pathfinder.Executable.BaseExecutable
{
    private Computer targetComputer;//定义一个用于存储或者说代指当前连接节点的变量
    private int netPort;//定义一个用来存储端口（号）的变量


    public EntechPortExploit(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args)
    {
        this.ramCost = 200;//你的内存占用
        this.IdentifierName = "WEBPORT INJECTOR";//你的程序在ram栏显示的名称
        //输入this.查看更多可定义的项目
    }

    public override void LoadContent()//首次执行后触发的内容
    {
        base.LoadContent();
        targetComputer = (os.connectedComp != null) ? os.connectedComp : os.thisComputer;//人话：目标计算机=（如果你现在连计算机了）获取当前连接的计算机 不然 就这个电脑了。
        if (targetComputer == null)//万一真没连怎么办呢？
        {
            os.write("ERROR: Target computer not found!");//没找到节点
            needsRemoval = true;//直接消失
            return;//返回
        }
        netPort = targetComputer.GetDisplayPortNumberFromCodePort(1270);//从目标计算机上得到端口号为1270的端口
        if (Args.Length < 2 || !Int32.TryParse(Args[1], out int port) || port != netPort)
        /*这个条件在以下任一情况下会返回 true：

          参数不足（少于2个）
          第二个参数不是有效数字
          端口号与期望值不匹配
        （索引为EXENAME(0号位置) 1270（1号位置））
        */
        {
            os.write("ERROR FOUND!Target Port is Closed or Missing!");//没找到你说的端口
            needsRemoval = true;//直接消失
            return;
        }
    }
    private float lifetime = 20f;
    private float time = 0f;
    
    public override void Draw(float t)//你觉得呢？
    {
        base.Draw(t);
        drawTarget();
        drawOutline();
        Vector2 centerpos = new(bounds.Width / 2, bounds.Height / 2); // 计算窗口中心位置
        string progressText = $"NEEDTIME {lifetime}"; // 显示剩余时间
    }


    public override void Update(float t)//循环触发（每帧）
    {
        base.Update(t);
        lifetime -= t;
        if (lifetime <= 20f)
        {

            lifetime = 0f;
            int targetPort = targetComputer.GetDisplayPortNumberFromCodePort(1720);//如果不加这一行会导致端口重映射后破解器失效比如下面这么写
            /*
            targetComputer.openPort(1720, os.thisComputer.ip);//打开端口
            */
            targetComputer.openPort(targetPort, os.thisComputer.ip);//打开端口
            isExiting = true;//缓慢消失
        }
    }
}




```
现在，按下**CTRL+SHIFT+B**编译，然后找到老地方的dll替换掉你拓展的第一次编译的dll。

打开你的拓展的一个节点，然后在端口处添加你1270端口，并在bin里写上#EnTechPortExploit#，打开游戏运行破解器，你就可以看见效果了。

（Tips：在快捷方式后面空格并添加字段使用参数启动-enabledebug -enablefc -allowextpublish就可以直接使用fh快速破解节点，使用dscan 节点ID 显示节点。）








